# План рефакторинга конфигурации rate limiting

Этот план описывает шаги по удалению функциональности rate limiting для клиентов и упрощению конфигурации, оставляя только лимит по моделям как параметр верхнего уровня.

## 1. Изменение конфигурации (Config)

- **Файл**: `config.yaml`
    - Удалить секцию `rateLimiting`.
    - Добавить параметр верхнего уровня `modelRequestsPerMinute` (число, опционально, default: 100).
    - Пример нового формата:
      ```yaml
      # Model rate limiting
      modelRequestsPerMinute: 100
      ```

- **Файл**: `src/config/router-config.interface.ts`
    - Удалить импорт и использование `RateLimitingConfig`.
    - Добавить поле `modelRequestsPerMinute?: number;` в интерфейс `RouterConfig`.

- **Файл**: `src/modules/rate-limiter/interfaces/rate-limiter.interface.ts`
    - Удалить `RateLimitingConfig` и связанные интерфейсы, если они больше не нужны, или упростить их.
    - Оставить типы для `TokenBucket` и `RateLimitStatus` (если статус еще нужен для мониторинга).

## 2. Обновление валидации и загрузки конфигурации

- **Файл**: `src/config/validators/router-config-validator.ts`
    - Удалить валидацию `rateLimiting`.
    - Добавить валидацию для `modelRequestsPerMinute` (должно быть положительным числом, если задано).

- **Файл**: `src/config/validators/rate-limiting-validator.ts`
    - Удалить этот файл, так как сложная структура rate limiting больше не используется.

## 3. Рефакторинг сервиса RateLimiterService

- **Файл**: `src/modules/rate-limiter/rate-limiter.service.ts`
    - Обновить конструктор: читать `modelRequestsPerMinute` из `config`.
    - Удалить всю логику `clientBuckets`, `checkClient`, `getRateLimitInfo` (так как она была завязана на клиенте).
    - Упростить `checkAll`: теперь проверяет только модель.
    - Удалить логику, связанную с `cleanUp` для клиентских бакетов.
    - Переименовать методы/переменные, если нужно, чтобы отразить, что теперь есть только лимит моделей.

## 4. Обновление RateLimiterGuard

- **Файл**: `src/modules/rate-limiter/rate-limiter.guard.ts`
    - Убедиться, что он вызывает правильные методы сервиса.
    - Так как guard обычно защищает *входящие* HTTP запросы, а `perModel` лимит скорее относится к исходящим или выбору модели, нужно проверить, где используется этот guard.
    - **Важно**: Если `perModel` лимит должен работать при выборе модели, то, возможно, Guard на уровне контроллера не имеет смысла (так как мы еще не знаем, какая модель будет выбрана), ИЛИ он должен пропускать запрос, а лимит модели проверяться позже.
    - Если Guard проверял `perClient`, то теперь он, вероятно, не нужен вовсе, так как Gateway занимается этим. **Решение**: Удалить `RateLimiterGuard` из глобальных гардов или контроллеров, если он только проверял клиентов. Лимит модели должен проверяться в `RouterService` или `SelectorService` перед вызовом модели.
    - *Уточнение*: В текущем коде `checkAll` принимал `modelName`. Если `RateLimiterGuard` не знает имя модели (например, если оно в теле запроса, а гард работает до парсинга или просто на уровне маршрута), то он не может применить лимит модели. Проверим этот момент в коде. Скорее всего, лимит модели проверяется внутри сервисов роутинга.

## 5. Обновление тестов

- **Папка**: `test/unit/modules/rate-limiter/`
    - Обновить `rate-limiter.service.spec.ts`, удалив тесты для клиентов и обновив тесты для моделей с новой конфигурацией.
- **Папка**: `test/unit/config/`
    - Обновить тесты валидаторов.

## 6. Обновление документации

- **Файл**: `README.md`
    - Удалить раздел про настройки `rateLimiting`.
    - Добавить описание параметра `modelRequestsPerMinute`.
    - Упомянуть, что клиентский rate limiting должен настраиваться на API Gateway.

## 7. Удаление неиспользуемого кода

- Удалить файлы, ставшие ненужными (например, валидатор rate-limiting).

---
**Примечание**: Автор запроса указал "примени изменения на всем проекте, коде, тестах и readme".
